# MANIFIESTO SOBERANO DEL M√ìDULO DE TELEMETR√çA (Protocolo Sonda)
## VERSI√ìN 1.0

### **Directiva Soberana para el Desarrollo**

**SE RECONOCE ESTE DOCUMENTO COMO LA √öNICA FUENTE DE VERDAD (SSOT) PARA EL M√ìDULO DE TELEMETR√çA Y OBSERVABILIDAD DEL ECOSISTEMA RAZVIRAL. LA MISI√ìN ES IMPLEMENTAR, MANTENER Y HACER CUMPLIR LOS PRINCIPIOS Y ESTRUCTURAS AQU√ç DEFINIDOS PARA LOGRAR UNA OBSERVABILIDAD UNIFICADA A TRAV√âS DE LA FRONTERA NATIVA (DART <-> C++).**

---

### **1. üèõÔ∏è Filosof√≠a y Principios Ra√≠z**

El prop√≥sito de este m√≥dulo es dotar a `razviral` de **Observabilidad de Rendimiento y Uso Hiper-Granular**. No es un simple logger; es el registrador de vuelo que captura cada operaci√≥n de renderizado y cada interacci√≥n del usuario, permiti√©ndonos diagnosticar fallos, medir cuellos de botella de rendimiento y entender c√≥mo se utiliza la aplicaci√≥n en el mundo real.

*   **Unificaci√≥n:** El `logger` **DEBE** poder ser invocado desde Dart y desde C++, y ambos tipos de logs **DEBEN** poder ser correlacionados a trav√©s de un `traceId` com√∫n.
*   **Resiliencia (Cliente):** La p√©rdida de eventos de telemetr√≠a es inaceptable. Se implementar√° una cola persistente en el dispositivo (usando una base de datos local como `sembast` o `Isar`) con reintentos y env√≠o por lotes para garantizar la entrega al backend.
*   **Alto Rendimiento:** El acto de registrar un evento **NUNCA** debe bloquear el hilo de la UI (en Dart) ni el hilo de renderizado (en C++). Las operaciones son as√≠ncronas y optimizadas.
*   **Estructura Sem√°ntica:** Los eventos son datos estructurados que siguen un contrato inmutable (una clase en Dart). Esto es crucial para permitir el an√°lisis, la creaci√≥n de dashboards de monitoreo (ej. tiempo promedio de renderizado por modelo de dispositivo) y la configuraci√≥n de alertas.

---

### **2. üèóÔ∏è Arquitectura y Estructura del M√≥dulo**

*   **Ubicaci√≥n Can√≥nica (L√≥gica Principal):** `apps/mobile/lib/src/shared/telemetry/`
*   **Ubicaci√≥n Can√≥nica (Contrato FFI):** `libs/core-engine/include/razviral_telemetry.h`

#### **Componentes (Archivos y Responsabilidades):**

1.  **`apps/mobile/lib/src/shared/telemetry/sonda_contracts.dart`**
    *   **Responsabilidad:** Definir el **Contrato Soberano** de datos de telemetr√≠a como clases de Dart inmutables.
    *   **Contenido:**
        *   `enum EventStatus { success, failure, inProgress }`
        *   `enum EventDomain { coreEngine, ui, system }`
        *   `class SondaEvent`: La estructura completa de un evento, incluyendo `eventId`, `traceId`, `taskId`, `status`, `durationMs`, `domain`, `action`, `payload` (un `Map<String, dynamic>`), etc.

2.  **`apps/mobile/lib/src/shared/telemetry/sonda_emitter.dart`**
    *   **Responsabilidad:** Contener la l√≥gica principal del `logger` en Dart.
    *   **Contenido:**
        *   Una instancia singleton del `Logger`.
        *   La l√≥gica de la cola, la persistencia en la base de datos local y el env√≠o por lotes al backend.
        *   Un m√©todo `init()` que pasar√° un puntero de funci√≥n a C++ para que el c√≥digo nativo pueda enviar logs de vuelta a Dart.

3.  **`libs/core-engine/include/razviral_telemetry.h`**
    *   **Responsabilidad:** Definir la interfaz que C++ usar√° para comunicarse con el sistema de logging de Dart.
    *   **Contenido:**
        *   Un `typedef` para el puntero de la funci√≥n de callback: `typedef void (*log_callback_f)(const char* event_json);`
        *   Una funci√≥n `razviral_telemetry_init(log_callback_f callback);` que el `core-engine` usar√° para almacenar el puntero de la funci√≥n de Dart.

4.  **`libs/core-engine/src/telemetry/sonda_emitter.cpp`**
    *   **Responsabilidad:** Proveer una funci√≥n C++ simple que el resto del `core-engine` pueda llamar.
    *   **Contenido:**
        *   Una funci√≥n `LogToDart(SondaEvent event)` que convierte el evento a una cadena JSON y llama al `callback` si ha sido inicializado.

---

### **3. ‚öôÔ∏è Flujo de Datos y Funcionamiento**

1.  **Inicializaci√≥n:** Al arrancar la app de Flutter, se llama a `Logger.init()`. Este m√©todo obtiene un puntero a una funci√≥n est√°tica de Dart (usando `Pointer.fromFunction`) y lo pasa a C++ llamando a `razviral_telemetry_init()`. El `core-engine` ahora sabe c√≥mo "hablar" con Dart.
2.  **Log desde C++:** Durante el renderizado, el `core-engine` necesita registrar una m√©trica. Llama a `LogToDart({ domain: "coreEngine", ... })`. Esta funci√≥n interna formatea un JSON y ejecuta el `callback` almacenado.
3.  **Log desde Dart:** El usuario presiona un bot√≥n. El c√≥digo de Flutter llama a `logger.info({ domain: "ui", ... })`.
4.  **Encolamiento:** Tanto los eventos que llegan desde C++ (v√≠a el callback) como los que se originan en Dart se convierten en objetos `SondaEvent` y se a√±aden a la cola persistente en la base de datos local del dispositivo.
5.  **Env√≠o:** La cola se vac√≠a y se env√≠a al endpoint `/api/telemetry/ingest` cuando se cumple una de estas condiciones:
    *   Ha pasado el intervalo de tiempo (ej. 1 minuto).
    *   Se alcanza el tama√±o m√°ximo del lote (ej. 50 eventos).
    *   La aplicaci√≥n entra en segundo plano.
6.  **Resiliencia:** Si el dispositivo no tiene conexi√≥n a internet o la llamada a la API de ingesta falla, los eventos permanecen seguros en la base de datos local para el pr√≥ximo intento, garantizando **cero p√©rdida de datos**.

---

### **4. üìã Protocolo de Uso Obligatorio**

1.  **Instrumentaci√≥n de Procesos Cr√≠ticos (Core Engine):**
    *   El proceso de renderizado de video **DEBE** ser el principal usuario.
    *   Todo el proceso de renderizado **DEBE** estar envuelto en eventos de inicio y fin para medir el tiempo total.
    *   Fases clave (decodificaci√≥n de un clip, aplicaci√≥n de un filtro) **DEBEN** tener sus propios eventos anidados para una medici√≥n granular del rendimiento.

2.  **Manejo de Errores (Resiliencia):**
    *   Todo bloque `catch` en Dart que maneje una excepci√≥n de la FFI **DEBE** invocar `logger.error(...)`.
    *   Toda funci√≥n en C++ que retorne un c√≥digo de error **DEBE** generar un evento de log con `status: failure` antes de retornar.

3.  **Interacciones de UI (Flutter):**
    *   Eventos clave como la selecci√≥n de medios, la elecci√≥n de una canci√≥n, el inicio del renderizado y el evento de "compartir" **DEBEN** ser registrados con el `logger`.

---

### **5. üîó Dependencias Externas al M√≥dulo**

Para que este m√≥dulo funcione en su totalidad, el ecosistema `razviral` **DEBE** proveer:

1.  **Un Endpoint de Ingesta en un Backend:** Se necesita un servicio web simple (ej. Cloud Function, Lambda) que reciba los eventos desde la aplicaci√≥n.
2.  **Una Base de Datos de Telemetr√≠a:** El backend insertar√° los eventos en una base de datos optimizada para an√°lisis (ej. BigQuery, ClickHouse) para la persistencia a largo plazo y la creaci√≥n de dashboards.
3.  **Una Librer√≠a de Base de Datos Local en Flutter:** La aplicaci√≥n de Flutter **DEBE** incluir una dependencia a una base de datos como `sembast`, `Isar` o `Hive` para la cola persistente.

---

