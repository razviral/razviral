# MANIFIESTO SOBERANO DEL CONTRATO: `libs/core-engine/include` (El Diccionario Nativo)
## VERSI√ìN 1.0

### **Directiva Soberana para el Desarrollo**

**SE RECONOCE ESTE DOCUMENTO COMO LA √öNICA FUENTE DE VERDAD (SSOT) PARA LOS CONTRATOS DE DATOS QUE CRUZAN LA FRONTERA NATIVA (FFI) DEL ECOSISTEMA RAZVIRAL. LA MISI√ìN ES CENTRALIZAR, MANTENER Y HACER CUMPLIR EL USO DE LAS ESTRUCTURAS DE DATOS Y ENUMERACIONES DEFINIDAS EN LOS ARCHIVOS DE CABECERA P√öBLICOS DEL `core-engine`. ESTE APARATO ES EL ADN DE LA COMUNICACI√ìN ENTRE LA UI DE FLUTTER Y EL MOTOR DE VIDEO NATIVO.**

---

### **1. üèõÔ∏è Filosof√≠a y Principios Ra√≠z**

El prop√≥sito de este aparato es ser el **"Diccionario Soberano de la Interfaz Nativa"**. Su funci√≥n es eliminar la ambig√ºedad y prevenir la desincronizaci√≥n de la representaci√≥n de datos entre la capa de Dart (que gestiona la UI y el estado) y la capa de C++ (que realiza el trabajo pesado de procesamiento de video).

*   **Doctrina `C-Header-First`:** La verdad de un contrato de datos no es su clase en Dart, sino su `struct` o `enum` en un archivo de cabecera p√∫blico de C. **La API p√∫blica en C es la SSoT.**
*   **Reflejo sobre Declaraci√≥n:** Las clases de Dart que modelan estos datos son un producto derivado del contrato en C, garantizando una sincronizaci√≥n binaria perfecta y sin esfuerzo.
*   **Centralizaci√≥n Absoluta:** No existir√° otra fuente de verdad para los contratos de la FFI en todo el monorepo. Cualquier duplicaci√≥n o suposici√≥n sobre la estructura de datos ser√° considerada una violaci√≥n arquitect√≥nica.
*   **Protecci√≥n de Fronteras:** Este aparato provee las "estructuras de paso" que todo dato debe adoptar al cruzar la frontera FFI (par√°metros de una funci√≥n nativa, datos de retorno, estructuras para callbacks).

---

### **2. üèóÔ∏è Arquitectura y Estructura del Aparato**

*   **Ubicaci√≥n Can√≥nica de la Verdad:** `libs/core-engine/include/`
*   **Punto de Entrada Soberano:** `libs/core-engine/include/librazviral_api.h`

#### **Estructura de Archivos:**
libs/core-engine/include/
‚îú‚îÄ‚îÄ librazviral_api.h # Punto de entrada que define la API de funciones y los handles opacos.
‚îî‚îÄ‚îÄ razviral_types.h # Definiciones de structs y enums que se usan en la API.
code
Code
### **3. ‚öôÔ∏è Flujo de Trabajo y Protocolos de Uso**

#### **Protocolo de Creaci√≥n/Modificaci√≥n de un Contrato:**

1.  **Definir la Necesidad:** Se identifica la necesidad de pasar datos estructurados entre Dart y C++ (ej. configuraci√≥n de renderizado, metadatos de un clip).
2.  **Definir la `struct` o `enum` en C:** En el archivo `razviral_types.h`, se crear√° la estructura en C. Se usar√°n tipos de ancho fijo (ej. `int32_t`, `double`) para garantizar la compatibilidad entre arquitecturas.

    **Ejemplo Pr√°ctico en `razviral_types.h`:**
    ```c
    // // libs/core-engine/include/razviral_types.h

    #ifndef RAZVIRAL_TYPES_H
    #define RAZVIRAL_TYPES_H

    #include <stdint.h>

    /**
     * @brief Define la calidad y formato del video de salida.
     * Este struct se pasa desde Dart a C++ para configurar el renderizador.
     */
    typedef struct {
        int32_t width;
        int32_t height;
        int32_t bitrate_kbps;
        int32_t fps;
    } RazviralRenderConfig;

    /**
     * @brief Define los posibles estados del motor de renderizado.
     * Este enum puede ser devuelto por funciones C++ para informar a Dart.
     */
    typedef enum {
        RAZVIRAL_STATUS_IDLE,
        RAZVIRAL_STATUS_RENDERING,
        RAZVIRAL_STATUS_SUCCESS,
        RAZVIRAL_STATUS_ERROR
    } RazviralEngineStatus;

    #endif // RAZVIRAL_TYPES_H
    ```
3.  **Usar el Contrato en la API:** La API principal en `librazviral_api.h` usar√° estos nuevos tipos en sus firmas de funci√≥n.
4.  **Crear la Clase de Dart Correspondiente:** En la capa de Dart (ej. `apps/mobile/lib/src/core_engine/contracts.dart`), se crear√° una clase que sea un reflejo 1 a 1 de la `struct` de C.

    **Ejemplo Pr√°ctico en `contracts.dart`:**
    ```dart
    // // apps/mobile/lib/src/core_engine/contracts.dart

    import 'dart:ffi';
    import 'package:ffi/ffi.dart';

    // Clase Dart que refleja el struct RazviralRenderConfig de C.
    // La anotaci√≥n @Packed(1) o @Packed(4) puede ser necesaria para
    // asegurar que no haya padding de memoria.
    final class RazviralRenderConfig extends Struct {
      @Int32()
      external int width;

      @Int32()
      external int height;

      @Int32()
      external int bitrateKbps;

      @Int32()
      external int fps;
    }

    // Enum de Dart que refleja el enum RazviralEngineStatus de C.
    enum RazviralEngineStatus {
      idle,
      rendering,
      success,
      error;

      static RazviralEngineStatus fromNative(int value) {
        // L√≥gica para convertir el int de C al enum de Dart.
        return RazviralEngineStatus.values[value];
      }
    }
    ```

#### **Protocolo de Uso en el `core-engine` (C++):**

*   **Firma de Funciones:** Las funciones exportadas en la API usar√°n punteros a estas `structs` como par√°metros (ej. `int razviral_project_render(..., const RazviralRenderConfig* config)`).
*   **Consistencia Interna:** El c√≥digo C++ interno **DEBE** usar estos `structs` p√∫blicos para cualquier dato que necesite ser expuesto a la capa de Dart.

#### **Protocolo de Uso en la App de Flutter:**

*   **Capa de Abstracci√≥n (Repositorio):** Se crear√° una clase en Dart (ej. `CoreEngineRepository`) que ser√° la √∫nica responsable de la comunicaci√≥n FFI. Esta clase manejar√° la alocaci√≥n de memoria para los `Structs` de Dart (`calloc<RazviralRenderConfig>()`), el llenado de sus campos y el paso de sus punteros a C++.
*   **Modelos de Dominio:** La UI de Flutter **NO** usar√° directamente las clases `Struct` de la FFI. En su lugar, el `CoreEngineRepository` las mapear√° a clases de dominio de Dart limpias (Plain Old Dart Objects), desacoplando completamente la UI de los detalles de la FFI.
*   **Gesti√≥n de Estado (Riverpod):** Los `Providers` de Riverpod que interact√∫en con el motor nativo consumir√°n el `CoreEngineRepository` y expondr√°n los modelos de dominio limpios al resto de la aplicaci√≥n.

Este aparato es la columna vertebral de la estabilidad y la integridad de la comunicaci√≥n nativa en `razviral`. Su correcta implementaci√≥n y uso riguroso son **innegociables**.

---
